# -*- coding: utf-8 -*-
"""Formal analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UPuIwwUYfYkhFN8oql_cHnFj0i1wlimS
"""

!pip install biomart
!pip install fastcluster
!pip install gseapy

"""### Libraries"""

# Libraries
import seaborn as sns
import pandas as pd
import scipy
import numpy as np
from matplotlib import pyplot as plt
from sklearn.decomposition import PCA
import matplotlib.colors
from matplotlib.lines import Line2D
import gseapy as gp
import networkx as nx


from scipy.spatial.distance import pdist, squareform
from sklearn.preprocessing import StandardScaler

from biomart import BiomartServer
from io import StringIO
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.metrics import silhouette_score
from sklearn.tree import export_graphviz

import graphviz
import statsmodels.api as sm

"""### Drive access"""

# Mount Google Drive. Permit access when prompted.
from google.colab import drive
from google.colab import files
drive.mount('/content/google_drive')

import os
os.chdir('/content/google_drive/MyDrive/')

"""### Upload data frames"""

# Check directory for file names
directory_files = os.listdir('/content/google_drive/MyDrive/440 project E + V 4ever/Data')
for file in directory_files:
  print(file)

original_df = pd.read_csv('440 project E + V 4ever/Data/All_data.txt', sep = '\t')

"""### Cleaning data"""

# Clean NA from dataset
original_df.dropna()
original_df

# Notes on original_df:
# Patients 5, 7, and 12 are missing because they didn't receive biopsies at week 12
# Patients 5, 6, and 7 are non-responders; thus, original_df includes data from a non-responder (patient 6)

# This df only includes controls and responders - drop the non-responder P6
# Controls = columns 1-3 (n = 3)
# Patients t0 = columns 4-11 (n = 8)
# Patients t12 = 12-19 (n = 8)

df_responders = original_df.drop(columns=['P6_0', 'P6_12'])
df_responders

# Groups

controls = pd.DataFrame(columns = ['C0', 'C1', 'C2'])
controls['C0'] = df_responders.iloc[:,1]
controls['C1'] = df_responders.iloc[:,2]
controls['C2'] = df_responders.iloc[:,3]

p0 = pd.DataFrame(columns = ['P1', 'P2', 'P3','P4', 'P8', 'P9','P10', 'P11'])
p0['P1'] = df_responders.iloc[:,4]
p0['P2'] = df_responders.iloc[:,5]
p0['P3'] = df_responders.iloc[:,6]
p0['P4'] = df_responders.iloc[:,7]
p0['P8'] = df_responders.iloc[:,8]
p0['P9'] = df_responders.iloc[:,9]
p0['P10'] = df_responders.iloc[:,10]
p0['P11'] = df_responders.iloc[:,11]

p12 = pd.DataFrame(columns = ['P1', 'P2', 'P3','P4', 'P8', 'P9','P10', 'P11'])
p12['P1'] = df_responders.iloc[:,12]
p12['P2'] = df_responders.iloc[:,13]
p12['P3'] = df_responders.iloc[:,14]
p12['P4'] = df_responders.iloc[:,15]
p12['P8'] = df_responders.iloc[:,16]
p12['P9'] = df_responders.iloc[:,17]
p12['P10'] = df_responders.iloc[:,18]
p12['P11'] = df_responders.iloc[:,19]

"""### Shapiro Wilk (normality)"""

# Test each group (controls, P_0, P_12) for normality

normal_results = []
for a in range(len(df_responders)):
  s_test_c, s_p_c = scipy.stats.shapiro(controls.iloc[a,:])

  s_test_p0, s_p_p0 = scipy.stats.shapiro(p0.iloc[a,:])

  s_test_p12, s_p_p12 = scipy.stats.shapiro(p12.iloc[a,:])

  normal_results.append({
    'ID_REF': df_responders.iloc[a, 0],
    'C_pvalue': s_p_c,
    'P0_pvalue': s_p_p0,
    'P12_pvalue': s_p_p12
  })

shapiro_results = pd.DataFrame(normal_results)
shapiro_results

"""### Mann Whitney"""

# There are a large number of non-normal distributions in our data, so use non-parametric statistics for DEG analysis
# Mann-Whitney U test

mann_results = []
for a in range(len(df_responders)):
  c_p0_test, c_p0_p = scipy.stats.mannwhitneyu(controls.iloc[a,:],p0.iloc[a,:])

  log2fc_1 = np.mean(p0.iloc[a,:])-np.mean(controls.iloc[a,:])

  c_p12_test, c_p12_p = scipy.stats.mannwhitneyu(controls.iloc[a,:],p12.iloc[a,:])

  log2fc_2 = np.mean(p12.iloc[a,:])-np.mean(controls.iloc[a,:])

  p0_p12_test, p0_p12_p = scipy.stats.mannwhitneyu(p0.iloc[a,:],p12.iloc[a,:])

  log2fc_3 = np.mean(p12.iloc[a,:])-np.mean(p0.iloc[a,:])

  mann_results.append({
    'ID_REF': df_responders.iloc[a, 0],
    'C vs P0 pvalue': c_p0_p,
    'C vs P0 log2fc': log2fc_1,
    'C vs P12 pvalue': c_p12_p,
    'C vs P12 log2fc': log2fc_2,
    'P0 vs P12 pvalue': p0_p12_p,
    'P0 vs P12 log2fc': log2fc_3
  })

mann_whitney_results = pd.DataFrame(mann_results)
mann_whitney_results

"""### T Test"""

# Student's T test

t_results = []
for a in range(len(df_responders)):
  c_p0_test, c_p0_p = scipy.stats.ttest_ind(controls.iloc[a,:],p0.iloc[a,:])

  log2fc_1 = np.mean(p0.iloc[a,:])-np.mean(controls.iloc[a,:])

  c_p12_test, c_p12_p = scipy.stats.ttest_ind(controls.iloc[a,:],p12.iloc[a,:])

  log2fc_2 = np.mean(p12.iloc[a,:])-np.mean(controls.iloc[a,:])

  p0_p12_test, p0_p12_p = scipy.stats.ttest_ind(p0.iloc[a,:],p12.iloc[a,:])

  log2fc_3 = np.mean(p12.iloc[a,:])-np.mean(p0.iloc[a,:])

  t_results.append({
    'ID_REF': df_responders.iloc[a, 0],
    'C vs P0 pvalue': c_p0_p,
    'C vs P0 log2fc': log2fc_1,
    'C vs P12 pvalue': c_p12_p,
    'C vs P12 log2fc': log2fc_2,
    'P0 vs P12 pvalue': p0_p12_p,
    'P0 vs P12 log2fc': log2fc_3
  })

t_test_results = pd.DataFrame(t_results)
t_test_results

# Make tables of the significant genes for each comparison for the supplement
CvsP0 = t_test_results.loc[(t_test_results['C vs P0 pvalue'] < 0.05) & (abs(t_test_results['C vs P0 log2fc'] > 1))]
CvsP12 = t_test_results.loc[(t_test_results['C vs P12 pvalue'] < 0.05) & (abs(t_test_results['C vs P12 log2fc'] > 1))]
P0vsP12 = t_test_results.loc[(t_test_results['P0 vs P12 pvalue'] < 0.05) & (abs(t_test_results['P0 vs P12 log2fc'] > 1))]

# Save csv files to our drive folder
CvsP0.drop(columns = ['C vs P12 pvalue','C vs P12 log2fc', 'P0 vs P12 pvalue', 'P0 vs P12 log2fc']).to_csv('/content/google_drive/MyDrive/440 project E + V 4ever/CvsP0.csv')
CvsP12.drop(columns = ['C vs P0 pvalue','C vs P0 log2fc', 'P0 vs P12 pvalue', 'P0 vs P12 log2fc']).to_csv('/content/google_drive/MyDrive/440 project E + V 4ever/CvsP12.csv')
P0vsP12.drop(columns = ['C vs P12 pvalue','C vs P12 log2fc', 'C vs P0 pvalue', 'C vs P0 log2fc']).to_csv('/content/google_drive/MyDrive/440 project E + V 4ever/P0vsP12.csv')

"""### Enrichment analysis"""

unique_affy_ids = t_test_results['ID_REF'].unique()  # Ensure unique IDs

# Connect to the BioMart server
server = BiomartServer("http://www.ensembl.org/biomart")

# Select the appropriate dataset; for human genes, use 'hsapiens_gene_ensembl'
dataset = server.datasets['hsapiens_gene_ensembl']

# Perform the search
# Adjust 'attributes' and 'filters' accordingly
# Affymetrix array used: 'affy_hg_u133_plus_2'
response = dataset.search({
    'filters': {
        'with_affy_hg_u133_plus_2': True  # Get all genes with Affy HG U133 Plus 2.0
        },
    'attributes': [
        'affy_hg_u133_plus_2',  # Affymetrix ID
        'ensembl_gene_id',     # Ensembl Gene ID
        'external_gene_name'   # Gene name
    ]
})

# Convert the response text to a DataFrame
hsapiens_ensembl = pd.read_csv(StringIO(response.text), sep='\t', names=['ID_REF', 'Ensembl_ID', 'Gene_Name'])

# Merge to find matches
matched_data_filtered = hsapiens_ensembl[hsapiens_ensembl['ID_REF'].isin(unique_affy_ids)]

# Merge t_test_results with gene names for annotation
t_test_results_with_genes = t_test_results.merge(matched_data_filtered, on='ID_REF', how='left')

CvsP0 = t_test_results_with_genes.loc[(t_test_results_with_genes['C vs P0 pvalue'] < 0.05) & (abs(t_test_results_with_genes['C vs P0 log2fc'] > 1))]
CvsP12 = t_test_results_with_genes.loc[(t_test_results_with_genes['C vs P12 pvalue'] < 0.05) & (abs(t_test_results_with_genes['C vs P12 log2fc'] > 1))]
P0vsP12 = t_test_results_with_genes.loc[(t_test_results_with_genes['P0 vs P12 pvalue'] < 0.05) & (abs(t_test_results_with_genes['P0 vs P12 log2fc'] > 1))]

# Save csv files to our drive folder
CvsP0.drop(columns = ['C vs P12 pvalue','C vs P12 log2fc', 'P0 vs P12 pvalue', 'P0 vs P12 log2fc']).to_csv('/content/google_drive/MyDrive/440 project E + V 4ever/Results/CvsP0.csv')
CvsP12.drop(columns = ['C vs P0 pvalue','C vs P0 log2fc', 'P0 vs P12 pvalue', 'P0 vs P12 log2fc']).to_csv('/content/google_drive/MyDrive/440 project E + V 4ever/Results/CvsP12.csv')
P0vsP12.drop(columns = ['C vs P12 pvalue','C vs P12 log2fc', 'C vs P0 pvalue', 'C vs P0 log2fc']).to_csv('/content/google_drive/MyDrive/440 project E + V 4ever/Results/P0vsP12.csv')

"""### Volcano plot"""

# Calculate -log10(p-value) for the y-axis for all comparisons
t_test_results_with_genes['neg_log10_C vs P0 pvalue'] = -np.log10(t_test_results_with_genes['C vs P0 pvalue'])
t_test_results_with_genes['neg_log10_C vs P12 pvalue'] = -np.log10(t_test_results_with_genes['C vs P12 pvalue'])
t_test_results_with_genes['neg_log10_P0 vs P12 pvalue'] = -np.log10(t_test_results_with_genes['P0 vs P12 pvalue'])

# Define thresholds for significance
logfc_threshold = 1  # log fold change threshold
pvalue_threshold = 0.05  # p-value threshold

# Initialize dictionaries to store significant genes for each comparison
significant_genes = {
    'C vs P0': {'upregulated': None, 'downregulated': None},
    'C vs P12': {'upregulated': None, 'downregulated': None},
    'P0 vs P12': {'upregulated': None, 'downregulated': None}
}

# Create subplots for each comparison
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

# Titles for the subplots
titles = ['C vs P0', 'C vs P12', 'P0 vs P12']


# Custom legend handles
legend_elements = [
    Line2D([0], [0], marker='o', color='w', label='Not significant',
           markerfacecolor='grey', markersize=10),
    Line2D([0], [0], marker='o', color='w', label='Upregulated',
           markerfacecolor='red', markersize=10),
    Line2D([0], [0], marker='o', color='w', label='Downregulated',
           markerfacecolor='blue', markersize=10),
]

# Iterate over the comparisons to create each subplot and filter/store significant genes
for i, (logfc_col, pval_col, title) in enumerate(zip(
        ['C vs P0 log2fc', 'C vs P12 log2fc', 'P0 vs P12 log2fc'],
        ['neg_log10_C vs P0 pvalue', 'neg_log10_C vs P12 pvalue', 'neg_log10_P0 vs P12 pvalue'],
        titles)):

    significant_up = t_test_results_with_genes[
        (t_test_results_with_genes[logfc_col] >= logfc_threshold) &
        (t_test_results_with_genes[pval_col.replace('neg_log10_', '')] <= pvalue_threshold)
    ]

    significant_down = t_test_results_with_genes[
        (t_test_results_with_genes[logfc_col] <= -logfc_threshold) &
        (t_test_results_with_genes[pval_col.replace('neg_log10_', '')] <= pvalue_threshold)
    ]

    non_significant = t_test_results_with_genes[
        (abs(t_test_results_with_genes[logfc_col]) < logfc_threshold) |
        (t_test_results_with_genes[pval_col.replace('neg_log10_', '')] > pvalue_threshold)
    ]

    # Store in dictionary
    significant_genes[title]['upregulated'] = significant_up
    significant_genes[title]['downregulated'] = significant_down

    # Scatter plot of non-significant points
    axes[i].scatter(
        x=non_significant[logfc_col],
        y=non_significant[pval_col],
        s=10,  # smaller marker size for non-significant points
        alpha=0.5,  # slightly transparent
        color='grey',  # grey color for non-significant points
        edgecolors='none'  # no edge color to markers
    )

    # Scatter plot of significant upregulated points
    axes[i].scatter(
        x=significant_up[logfc_col],
        y=significant_up[pval_col],
        s=50,  # larger marker size for significant points
        color='red',  # red color for significant upregulated points
        edgecolors='none'
    )

    # Scatter plot of significant downregulated points
    axes[i].scatter(
        x=significant_down[logfc_col],
        y=significant_down[pval_col],
        s=50,  # larger marker size for significant points
        color='blue',  # blue color for significant downregulated points
        edgecolors='none'
    )

    # For upregulated genes, this means the largest positive fold change
    top_genes_up = significant_up.sort_values(
        by=[pval_col.replace('neg_log10_', ''), logfc_col], ascending=[True, False]
        ).head(5)

    # For downregulated genes, this means the largest negative fold change
    top_genes_down = significant_down.sort_values(
        by=[pval_col.replace('neg_log10_', ''), logfc_col], ascending=[True, True]
        ).head(5)

    # Select top genes by smallest p-value for upregulated and downregulated
    #top_genes_up = significant_up.nsmallest(5, pval_col.replace('neg_log10_', ''))
    #top_genes_down = significant_down.nsmallest(5, pval_col.replace('neg_log10_', ''))

    # Combine top upregulated and downregulated genes
    top_genes = pd.concat([top_genes_up, top_genes_down])

    # Annotate top genes
    for _, row in top_genes.iterrows():
        ha = 'center'
        va = 'bottom' if row[logfc_col] > 0 else 'top'
        axes[i].text(
            row[logfc_col],
            row[pval_col],
            row['Gene_Name'],
            ha=ha,
            va=va,
            fontsize=9,  # Adjust fontsize according to your plot size
            color='darkgreen',  # Choose a color that is visible
            weight='bold',  # Bold text to make it stand out
            clip_on=True,  # Prevent clipping at edges
        )
    # Adding the legend to each subplot
    axes[i].legend(handles=legend_elements, loc='upper right')

    # Enhancing each subplot
    axes[i].set_title(f'Volcano Plot of {title}')
    axes[i].set_xlabel('Log2 Fold Change')
    axes[i].set_ylabel('-Log10(p-value)')
    axes[i].axhline(y=-np.log10(pvalue_threshold), color='black', linestyle='--', linewidth=1)
    axes[i].axvline(x=logfc_threshold, color='black', linestyle='--', linewidth=1)
    axes[i].axvline(x=-logfc_threshold, color='black', linestyle='--', linewidth=1)
    axes[i].grid(True, linestyle=':', color='grey')  # Add a dotted grid for better readability

    plt.savefig(f'/content/google_drive/MyDrive/440 project E + V 4ever/Results/Volcano Plot of {title}.jpeg')

plt.tight_layout()
plt.show()

# Dictionary to store the cleaned DataFrames
cleaned_data_frames = {}

# Iterate through the significant_genes to create, merge, and clean DataFrames
for group, data in significant_genes.items():
    # Combine upregulated and downregulated genes into one DataFrame with a 'Regulation' column
    upregulated_df = data['upregulated'].copy()
    upregulated_df['Regulation'] = 'upregulated'
    downregulated_df = data['downregulated'].copy()
    downregulated_df['Regulation'] = 'downregulated'
    combined_df = pd.concat([upregulated_df, downregulated_df])

    # Select specific columns and merge with df_responders
    significant_all_data = combined_df[['ID_REF', 'Ensembl_ID', 'Gene_Name', 'Regulation']].merge(df_responders, on='ID_REF', how='left')

    # Drop rows with any NaN values
    cleaned_df = significant_all_data.dropna()

    # Store the cleaned DataFrame in the dictionary
    cleaned_data_frames[group] = cleaned_df

# Now, cleaned_data_frames contains cleaned DataFrames for each group
# Accessing the cleaned DataFrames, for example:
C_vs_P0_cleaned = cleaned_data_frames['C vs P0']
C_vs_P12_cleaned = cleaned_data_frames['C vs P12']
P0_vs_P12_cleaned = cleaned_data_frames['P0 vs P12']

"""### Heatmap"""

# List of cleaned DataFrames
cleaned_data_frames = [C_vs_P0_cleaned, C_vs_P12_cleaned, P0_vs_P12_cleaned]
comparison_names = ['C vs P0', 'C vs P12', 'P0 vs P12']

for df, name in zip(cleaned_data_frames, comparison_names):

    # Adapting the dataframe for the heatmap
    heatmap_data = df.set_index('Gene_Name')
    heatmap_data_plot = heatmap_data.iloc[:, 3:]

    # Create the clustermap
    g = sns.clustermap(heatmap_data_plot, method='average', cmap='viridis', standard_scale=1,
                       xticklabels=True, yticklabels=True)

    plt.setp(g.ax_heatmap.get_yticklabels(), fontsize=1)  # Set fontsize to a readable size

    # Set the color bar to the new position
    pos = g.cax.get_position()
    g.cax.set_position([pos.x0 - 0.15, pos.y0, pos.width, pos.height])  # Adjust if necessary

    plt.title(f'Gene Expression Heatmap - {name}')
    plt.savefig(f'/content/google_drive/MyDrive/440 project E + V 4ever/Results/Gene Expression Heatmap (SNS) - {name}.jpeg')
    plt.show()

# Testing a new standardization method: z score instead of seaborn's method

# List of cleaned DataFrames
cleaned_data_frames = [C_vs_P0_cleaned, C_vs_P12_cleaned, P0_vs_P12_cleaned]
comparison_names = ['C vs P0', 'C vs P12', 'P0 vs P12']

for df, name in zip(cleaned_data_frames, comparison_names):

    # Adapting the dataframe for the heatmap
    heatmap_data = df.set_index('Gene_Name')
    heatmap_data_plot = heatmap_data.iloc[:, 3:]

    # Standardize values according using z-score
    means = []
    stds = []
    for a in range(len(heatmap_data_plot.iloc[0,:])):
      means.append(np.mean(heatmap_data_plot.iloc[:,a]))
      stds.append(np.std(heatmap_data_plot.iloc[:,a]))

    count = 0
    while count < len(heatmap_data_plot.iloc[0,:]):
      sub = 0
      while sub < len(heatmap_data_plot):
        heatmap_data_plot.iloc[sub,count] = (heatmap_data_plot.iloc[sub, count] - means[count])/stds[count]
        sub += 1
      count += 1

    # Create the clustermap
    g = sns.clustermap(heatmap_data_plot, method='average', cmap='viridis',
                       xticklabels=True, yticklabels=True)

    plt.setp(g.ax_heatmap.get_yticklabels(), fontsize=1)  # Set fontsize to a readable size

    # Set the color bar to the new position
    pos = g.cax.get_position()
    g.cax.set_position([pos.x0 - 0.15, pos.y0, pos.width, pos.height])  # Adjust if necessary

    plt.title(f'Gene Expression Heatmap - {name}')
    plt.savefig(f'/content/google_drive/MyDrive/440 project E + V 4ever/Results/Gene Expression Heatmap (Zscore) - {name}.jpeg')
    plt.show()

"""### KEGG"""

import warnings

warnings.simplefilter(action='ignore', category=FutureWarning)

def run_up_kegg_enrichment(df, comparison_name):
    upregulated_genes = df[df['Regulation'] == 'upregulated'].index.tolist()
    # Run KEGG enrichment analysis for upregulated genes
    up_kegg_enr = gp.enrichr(gene_list=upregulated_genes,
                             gene_sets='KEGG_2021_Human',
                             organism = 'human',
                             outdir=f'kegg_pathway_enrichment_results/{comparison_name}_upregulated',
                             no_plot=True)
    print(f"KEGG Enrichment Analysis (Upregulated) - {comparison_name}")
    print(up_kegg_enr.results.head())
    # Return the Enrichr object
    return up_kegg_enr

def run_down_kegg_enrichment(df, comparison_name):
    downregulated_genes = df[df['Regulation'] == 'downregulated'].index.tolist()
    # Run KEGG enrichment analysis for downregulated genes
    down_kegg_enr = gp.enrichr(gene_list=downregulated_genes,
                               gene_sets='KEGG_2021_Human',
                               organism = 'human',
                               outdir=f'kegg_pathway_enrichment_results/{comparison_name}_downregulated',
                               no_plot=True)
    # Return the Enrichr object

    return down_kegg_enr

def plot_kegg_enrichment_results(results_dict, regulation_type):
    for comparison_name, enrichr_obj in results_dict.items():
        # Check if the results DataFrame is empty
        if not enrichr_obj.results.empty:
            plt.figure(figsize=(3,5))
            # Create the dotplot
            gp.dotplot(enrichr_obj.res2d, title=f'{comparison_name} {regulation_type} KEGG Pathways',
                       cmap='viridis_r', y='Term', size=5)
            # Save the plot
            plt.savefig(f'kegg_dotplot_{comparison_name}_{regulation_type}.png')
            plt.show()  # Show the plot


data_frames_up = {'C vs P0': C_vs_P0_cleaned, 'C vs P12': C_vs_P12_cleaned, 'P0 vs P12': P0_vs_P12_cleaned}
data_frames_down = {'C vs P0': C_vs_P0_cleaned, 'P0 vs P12': P0_vs_P12_cleaned}
#C_vs_P12_cleaned was omitted for the down regulation since there was no enrich terms when cutoff = 0.05

# Assuming you have your data_frames_up and data_frames_down set up as before
up_kegg_results = {}
down_kegg_results = {}

for name, df in data_frames_up.items():
    up_kegg_results[name] = run_up_kegg_enrichment(df.set_index('Gene_Name'), name)

for name, df in data_frames_down.items():
    down_kegg_results[name] = run_down_kegg_enrichment(df.set_index('Gene_Name'), name)

# Now plot the results using dotplot
plot_kegg_enrichment_results(up_kegg_results, 'upregulated')
plot_kegg_enrichment_results(down_kegg_results, 'downregulated')

"""### GO"""

def run_up_go_enrichment(df, comparison_name):
    upregulated_genes = df[df['Regulation'] == 'upregulated'].index.tolist()
    # Run KEGG enrichment analysis for upregulated genes
    up_go_enr = gp.enrichr(gene_list=upregulated_genes,
                             gene_sets='GO_Biological_Process_2021',
                             organism = 'human',
                             outdir=f'go_enrichment_results/{comparison_name}_upregulated',
                             no_plot=True)
    # Return the Enrichr object
    return up_go_enr

def run_down_go_enrichment(df, comparison_name):
    downregulated_genes = df[df['Regulation'] == 'downregulated'].index.tolist()
    # Run KEGG enrichment analysis for downregulated genes
    down_go_enr = gp.enrichr(gene_list=downregulated_genes,
                               gene_sets='GO_Biological_Process_2021',
                               organism = 'human',
                               outdir=f'go_enrichment_results/{comparison_name}_downregulated',
                               no_plot=True)
    # Return the Enrichr object
    return down_go_enr

def plot_go_enrichment_results(results_dict, regulation_type):
    for comparison_name, enrichr_obj in results_dict.items():
        # Check if the results DataFrame is empty
        if not enrichr_obj.results.empty:
            plt.figure(figsize=(3,5))
            # Create the dotplot
            gp.dotplot(enrichr_obj.res2d, title=f'{comparison_name} {regulation_type} GO Pathways',
                       cmap='viridis_r', y='Term', size=5)
            # Save the plot
            plt.savefig(f'go_dotplot_{comparison_name}_{regulation_type}.png')
            plt.show()  # Show the plot


data_frames_up = {'C vs P0': C_vs_P0_cleaned, 'C vs P12': C_vs_P12_cleaned, 'P0 vs P12': P0_vs_P12_cleaned}
data_frames_down = {'C vs P0': C_vs_P0_cleaned, 'P0 vs P12': P0_vs_P12_cleaned}
#C_vs_P12_cleaned was omitted for the down regulation since there was no enrich terms when cutoff = 0.05

# Assuming you have your data_frames_up and data_frames_down set up as before
up_go_results = {}
down_go_results = {}

for name, df in data_frames_up.items():
    up_go_results[name] = run_up_go_enrichment(df.set_index('Gene_Name'), name)

for name, df in data_frames_down.items():
    down_go_results[name] = run_down_go_enrichment(df.set_index('Gene_Name'), name)

# Now plot the results using dotplot
plot_go_enrichment_results(up_go_results, 'upregulated')
plot_go_enrichment_results(down_go_results, 'downregulated')
